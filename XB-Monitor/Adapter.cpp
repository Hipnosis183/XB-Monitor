//
// XB-Monitor: Opensource EX-Board loader by Romhack
//

#include "stdafx.h"
#include <vector>

using namespace std;

static int isAddressed = 0;


int is_addressed()
{
	return isAddressed;
}


void reset_addressed()
{
	isAddressed = 0;
}


unsigned char SRAM[SRAM_SIZE];


void SRAM_save()
{
	FILE *fp = NULL;
	fp = fopen(SRAM_NAME, "wb");
	
	if (!fp)
		return;

	fwrite(SRAM, 1, SRAM_SIZE, fp);
	fclose(fp);
}


void SRAM_load()
{
	FILE *fp = NULL;
	fp = fopen(SRAM_NAME, "rb");
	
	memset(SRAM, 0, SRAM_SIZE);
	
	if (!fp)
		return;

	fread(SRAM, 1, SRAM_SIZE, fp);
	fclose(fp);
}


void SRAM_read(std::vector<char>& dst, unsigned int addr, unsigned char size)
{
	for (unsigned int i = 0; i < size; i++)
	{
		if (addr < SRAM_SIZE)
			dst.push_back(SRAM[addr]);
		else
			dst.push_back(0);
		addr++;	
	}
}


unsigned char tbl0[120] =
{
	0x00, 0x2A, 0x34, 0x2E, 0x20, 0xA1, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x24, 0x28, 
	0x80, 0x1A, 0x06, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x20, 0x32, 0x2C, 0xE0, 0x93, 0x04, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x03, 0x23, 0x20, 0x36, 0x40, 0x0D, 0x03, 0x00, 0x0A, 0x00, 0x00, 0x00, 
	0x04, 0x2B, 0x28, 0x22, 0xA0, 0x86, 0x01, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x2A, 0x34, 0x31, 
	0x90, 0x5F, 0x01, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x38, 0x34, 0x28, 0x80, 0x38, 0x01, 0x00, 
	0x05, 0x00, 0x00, 0x00, 0x07, 0x23, 0x34, 0x32, 0x70, 0x11, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x08, 0x2D, 0x2E, 0x20, 0x60, 0xEA, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x09, 0x24, 0x35, 0x24, 
	0x50, 0xC3, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00
};


unsigned char tbl1[120] =
{
	0x00, 0x2A, 0x34, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x31, 0x24, 0x28, 
	0x09, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x20, 0x32, 0x2C, 0x08, 0x00, 0x00, 0x00, 
	0x01, 0x00, 0x00, 0x00, 0x03, 0x23, 0x20, 0x36, 0x07, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 
	0x04, 0x2B, 0x28, 0x22, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x05, 0x2A, 0x34, 0x31, 
	0x05, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x06, 0x38, 0x34, 0x28, 0x04, 0x00, 0x00, 0x00, 
	0x05, 0x00, 0x00, 0x00, 0x07, 0x23, 0x34, 0x32, 0x03, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x08, 0x2D, 0x2E, 0x20, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x09, 0x24, 0x35, 0x24, 
	0x01, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00
};


unsigned char tbl2[160] =
{
	0x00, 0x2A, 0x34, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x01, 0x31, 0x24, 0x28, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 
	0x02, 0x20, 0x32, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 
	0x03, 0x23, 0x20, 0x36, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 
	0x04, 0x2B, 0x28, 0x22, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
	0x05, 0x2A, 0x34, 0x31, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 
	0x06, 0x38, 0x34, 0x28, 0x00, 0x00, 0x00, 0x00, 0x46, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 
	0x07, 0x23, 0x34, 0x32, 0x00, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 
	0x08, 0x2D, 0x2E, 0x20, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
	0x09, 0x24, 0x35, 0x24, 0x00, 0x00, 0x00, 0x00, 0x63, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00
};


static vector<char> r(1024);


DWORD process_stream(UINT8 *stream, DWORD srcsize, BYTE *dst, DWORD dstsize)
{
	r.clear();

	switch (stream[1])
	{
		case 0xfa:
		{
			unsigned int addr = 0;
			unsigned int size = 0;
			
			r.push_back(0x76);
			r.push_back(0xfa);
			r.push_back(0x05);
			r.push_back(0x70);
			r.push_back(0x42);

			addr = (stream[3] << 8) | (stream[4]);
			size = stream[5];

			if (size >= (srcsize - 1))
				size = srcsize - 1;
			if ((addr + size) >= 0xffff)
				size = 0xffff-addr;

			memcpy(&SRAM[addr], &stream[6], size);
			
			break;
		}
		
		#if 0
		
		case 0xfb:
		{
			r.push_back(0x76);
			r.push_back(0xfb);

			if (stream[4] == 0)
			{
				r.push_back(80 + 80 + 5);
				
				int a3 = 0;
				int a5 = 3;
				
				for (int i = 0; i < 20; i++)
				{
					if (i & 1)
					{
						for (int k = 0; k < 3; k++)
							r.push_back(tbl0[a3 + k]);
						a3 += 12;
					}
					
					else
					{
						for (int k = 0; k < 5; k++)
							r.push_back(tbl0[a5 + k]);
						a5 += 12;
					}
				}

				a3 = 1;
				a5 = 4;
				
				for (int i = 0; i < 20; i++)
				{
					if (i & 1)
					{
						for (int k = 0; k < 3; k++)
							r.push_back(tbl0[a3 + k]);
						a3 += 12;
					}
					
					else
					{
						for (int k = 0; k < 5; k++)
							r.push_back(tbl0[a5 + k]);
						a5 += 12;
					}
				}
			}
			
			else
			{
				r.push_back(0xf4);
				
				for (int i = 0; i < 0xef; i++)
					r.push_back(0);
			}
			
			r.push_back(0x70);
			r.push_back(0x42);
			
			break;
		}
			
		#else
		
		case 0xfb:
		{
			r.push_back(0x76);
			r.push_back(0xfb);

			unsigned int addr = 0;
			unsigned int size = stream[5];
			unsigned pos = r.size();
			
			r.push_back(5);

			addr = (stream[3] << 8) | (stream[4]);
			size = stream[5];

			if ((addr + size) >= 0xffff)
				size = 0xffff-addr;

			for (int i = 0; i < size; i++)
				r.push_back(SRAM[addr++]);

			r[pos] += size;

			r.push_back(0x70);
			r.push_back(0x42);
			
			break;
		}

		#endif
		
		case 0xfe:
		{
			r.push_back(0x76);
			r.push_back(0xfe);
			r.push_back(0x06);
			
			if (stream[3])
				r.push_back(0x01);
			else
				r.push_back(0);
			
			r.push_back(0x70);
			r.push_back(0x42);
			
			break;
		}			

		case 0x01:
		{
			r.push_back(0x76);
			r.push_back(0x01);
			r.push_back(0x06);
			r.push_back(0x00);
			r.push_back(0x70);
			r.push_back(0x42);
			
			isAddressed = 1;
			
			break;
		}
			
		case 0x08:
			isAddressed = 0;
		
		default:
			break;
	} 

	BYTE *pdst = dst;
	
	unsigned i = 0;
	unsigned maxv = r.size();

	if (maxv > dstsize)
		maxv = dstsize;

	for (i = 0; i < maxv; i++)
		*pdst++ = r[i];

	unsigned sz = r.size();

	return sz;
}